\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[x11names,table]{xcolor}
\usepackage[french]{babel}
\usepackage{wasysym}
\usepackage{natbib}
% Si l'on veut produire une version PDF avec distiller ou pdflatex:
\usepackage[pageanchor=false,colorlinks,plainpages=false]{hyperref}
\usepackage{url}

\ifx\pdftexversion\undefined
\usepackage[dvips]{graphicx}
\else
\usepackage[pdftex]{graphicx}
\DeclareGraphicsRule{*}{mps}{*}{}
\fi

\graphicspath{{Images/}}

\usepackage{time}
%\usepackage[scaled]{helvet}
%\renewcommand*\familydefault{\sfdefault} %% Only if the base font of the document is to be sans serif

\usepackage{listings}
\usepackage{textcomp}
 
\definecolor{gray}{gray}{0.5} 
\lstnewenvironment{code_xml}[1][]{ 
    \lstset
      { 
        language=XML,
        inputencoding=utf8,
        basicstyle=\ttfamily\footnotesize, 
        showspaces=false,
        showstringspaces=false,
        showtabs=false,
        frame=single,
        morecomment=[s]{<!--}{-->},
        commentstyle=\itshape\color{gray},
        stringstyle=\color{blue},
        keywordstyle=\color{red},
        markfirstintag=true,
        upquote=true
      } 
}{}

\lstnewenvironment{code_shell}[1][]{ 
    \lstset
      { 
        language=sh,
        inputencoding=utf8,
        basicstyle=\ttfamily\footnotesize, 
        showspaces=false,
        showstringspaces=false,
        showtabs=false,
        frame=single,
        commentstyle=\itshape\color{gray},
        stringstyle=\color{blue},
        keywordstyle=\color{red},
        upquote=true
      } 
}{}

\lstnewenvironment{code_java}[1][]{ 
    \lstset
      { 
        language=java,
        inputencoding=utf8,
        basicstyle=\ttfamily\normalsize, 
        showspaces=false,
        showstringspaces=false,
        showtabs=false,
        frame=single,
        commentstyle=\itshape\color{gray},
        stringstyle=\color{blue},
        keywordstyle=\color{red},
        upquote=true
      } 
}{}

\usepackage{todonotes}
\usepackage{tikz-er2}
\usepackage{pgf-umlcd}
\usetikzlibrary{decorations.text}
\usetikzlibrary{decorations.markings}
\usetikzlibrary{positioning}
\usetikzlibrary{shadows}
\usetikzlibrary{backgrounds}
\tikzstyle{every entity} = [top color=white, 
                            bottom color=blue!30, 
                            draw=blue!50!black!100, 
                            drop shadow]
\tikzstyle{every weak entity} = [drop shadow={shadow xshift=.7ex, shadow yshift=-.7ex}]
\tikzstyle{every attribute} = [top color=white, 
                               bottom color=yellow!20, 
                               draw=yellow, 
                               node distance=1cm, 
                               drop shadow]
\tikzstyle{every relationship} = [top color=white, 
                                  bottom color=yellow!20,  
                                  draw=yellow, 
                                  drop shadow]
\tikzstyle{every isa} = [draw=blue!50!black!100]

\usepackage[]{subfig}
%\renewcommand{\thesubfigure}{Figure~\thefigure.\arabic{subfigure}}
%\captionsetup[subfigure]{labelformat=simple,labelsep=colon, listofformat=subsimple}
%\captionsetup{lofdepth=2}
%\makeatletter
%\renewcommand{\p@subfigure}{}
%\makeatother

\usepackage{geometry}
\geometry{%
a4paper,
body={160mm,250mm},
left=25mm,top=20mm,
headheight=7mm,headsep=4mm,
marginparsep=3mm,
marginparwidth=27mm}

\usepackage{changepage}
\usepackage{placeins}

\usepackage{rotating}

\newenvironment{agrandirmarges}[2]{%
\begin{list}{}{%
\setlength{\topsep}{0pt}%
\setlength{\listparindent}{\parindent}%
\setlength{\itemindent}{\parindent}%
\setlength{\parsep}{0pt plus 1pt}%
\checkoddpage%
\ifoddpage
\setlength{\leftmargin}{-#1}\setlength{\rightmargin}{-#2}
\else
\setlength{\leftmargin}{-#2}\setlength{\rightmargin}{-#1}
\fi}\item }%
{\end{list}}

\newcounter{compteurQuestion}
\setcounter{compteurQuestion}{0}
\newcommand{\Question}{\paragraph*{Question~\thecompteurQuestion~:}\addtocounter{compteurQuestion}{1}}

\date{}
\begin{document}
\lstset{
         breaklines=true,                                     % line wrapping on
         %frame=ltrb,
         framesep=5pt,
         %samepage=true,
         tabsize=4,
         basicstyle=\normalsize,
         frameround=ftft,
         keywordstyle=\ttfamily\color{SeaGreen4},
         identifierstyle=\ttfamily\bfseries\color{RoyalBlue4},
         commentstyle=\color{RoyalBlue3},
         stringstyle=\ttfamily,
         showstringspaces=false
}
\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,main,foreground}

\newlength{\niveauZero}
\newlength{\niveauUn}
\newlength{\niveauDeux}
\newlength{\niveauTrois}
\newlength{\niveauQuatre}
\newlength{\niveauCinq}

\newlength{\colonneZero}
\newlength{\colonneUn}
\newlength{\colonneDeux}
\newlength{\colonneTrois}
\newlength{\colonneQuatre}
\newlength{\colonneCinq}


{\centering
    \mbox{
      \makebox[15cm][l]{
      \begin{minipage}{15cm}
        \begin{center}
          {\Huge Construction d'une Couche de Persistance}\\[1cm]
          {\Large Sébastien \textsc{Nedjar} et Fabien \textsc{Pesci}}
        \end{center}
      \end{minipage}
      }
    }
}\\[0.4cm]
\section{Introduction}

Dans le premier TP nous avons construit une couche DAO pour simplifier et uniformiser l'accès aux données. L'énorme 
avantage d'une telle couche est de fournir une couche d'abstraction intermédiaire relativement générique et 
interchangeable. Ainsi le passage d'une technologie de persistance à une autre peut se faire en remplaçant uniquement 
cette couche intermédiaire. Nous avons aussi constaté que l'écriture des classes DAO simplistes avec JDBC était une tache 
longue, fastidieuse et rébarbative. L'objectif de ce TP est d'utiliser JPA pour simplifier l'écriture des DAO et aussi 
améliorer la fiabilité et la souplesse de notre couche de persistance. 

Pour illustrer ce propos, nous utiliserons la base de données «~Gestion Pédagogique\footnote{Script de régénération disponible 
à l'adresse suivante : \url{http://allegro.iut.univ-aix.fr/~nedjar/gestion_peda_oracle.sql} ou 
\url{http://allegro.iut.univ-aix.fr/~nedjar/gestion_peda_mysql.sql}}~» que vous avez utilisée lors de vos TP de \textsc{Pl/Sql} 
en début d'année. Le modèle conceptuel des données est rappelé par la figure~\ref{mcd_gestion_peda}. La figure~\ref{uml_gestion_peda} 
est une traduction du schéma Entité/Association en un  diagramme de classe UML. Dans ce TP nous avons modifié la 
navigabilité de l'association "Est spécialiste" pour la rendre bi-directionnelle.

Avant de commencer ce TP, je suppose que vous avez compris les concepts du précédent et que vous avez suivi les tutoriels 
sur Maven et JPA.

\begin{figure}[bp]\centering
\begin{tikzpicture}[node distance=1.96cm, every edge/.style={link}]

  \node[entity] (mat) {
    \textbf{Module}
    \nodepart{second}
    \key{Code}\\
    Libellé\\
    H\_Cours\_Prev\\
    H\_Cours\_Rea\\
    H\_TP\_Prev\\
    H\_TP\_Rea\\
    Discipline\\
    Coef\_Test\\
    Coef\_CC\\
  };

  \node[entity] (etud) [below right =of mat ] {
    \textbf{Etudiant}
    \nodepart{second}
    \key{Num\_Et}\\
	  Nom\_Et\\
	  Prénom\_Et\\
	  CP\_Et\\
	  Ville\_Et\\
	  Année\\
	  Groupe\\
  };

  \node[entity] (ens) [above right=of etud ] {
    \textbf{Prof}
    \nodepart{second}
    \key{Num\_Prof}\\
	  Nom\_Prof\\
	  Prénom\_Prof\\
	  Adr\_Prof\\
	  CP\_Prof\\
	  Ville\_Prof\\
  };

  \node[relationship] (notation) [below =of mat] {Notation}
     child {node[attributes] {Moy\_CC\\Moy\_Test}};
  \draw[link] (mat) -- node [pos=0.15, auto] {(0,n)} (notation);
  \draw[link] (etud.145) -- node [pos=0.35, auto, swap] {(0,n)} (notation);

  \node[relationship] (enseigne) [above=of etud] {Enseignement};  
  \draw[link] (mat.315) -- node [pos=0.40, auto] {(0,n)} (enseigne.west);
  \draw[link] (ens.208) -- node [pos=0.40, auto, swap] {(0,n)} (enseigne.east);
  \draw[link] (etud) -- node [pos=0.15, auto, swap] {(0,n)} (enseigne);

  \node[relationship] (mat_spec) [above=1cm of enseigne] {Spécialiste};
  \draw[link] (mat.12) -- node [pos=0.35, auto] {(0,n)} (mat_spec);
  \draw[link] (ens.145) -- node [pos=0.35, auto, swap] {(1,1)} (mat_spec);
  
  \node[relationship] (resp) [above=1cm of mat_spec] {Responsable};
  \draw[link] (mat.56) -- node [pos=0.3, auto] {(1,1)} (resp);
  \draw[link] (ens.north) |- node [pos=0.15, auto, swap] {(0,n)} (resp.east);

  \node[relationship] (mat_pere) [left=1cm of mat] {A pour père};
  \draw[link] (mat.150) -| node [pos=0.1, auto, swap] {(1,1)} (mat_pere.north);
  \draw[link] (mat.210) -| node [pos=0.1, auto] {(0,n)} (mat_pere.south);
  
\end{tikzpicture}
\caption{Modèle conceptuel des données de la base «~Gestion Pédagogique~»\label{mcd_gestion_peda}}
\end{figure}

\begin{figure}\centering

\begin{tikzpicture}[]

\begin{class}[text width=2cm]{Module}{0,0}
\end{class}

\begin{class}[text width=2cm]{Prof}{10,0}
\end{class}

\begin{class}[text width=2cm]{Etudiant}{5,-4.5}
\end{class}

\begin{class}[text width=2cm]{Notation}{0,-6}
\end{class}

\draw [color=\umldrawcolor,text=\umltextcolor, rounded corners=2em, 
       decoration={markings,mark=at position 1 with {\arrow[scale=2]{angle 60}}},
       postaction={decorate}, shorten >=0.4pt] 
       (Module.north)  to ++(0,1) to node[above] {Est père de $\RHD$} ++(-2.5,0) to ++(0,-1.5) to node[pos=0.7, above]{1} (Module.west)
       node[very near end, above right]{*};

\draw [color=\umldrawcolor,text=\umltextcolor, bend left, 
       decoration={markings,mark=at position 1 with {\arrow[scale=2]{angle 60}}},
       postaction={decorate}, shorten >=0.4pt] 
(Module.20) to 
node[very near end, below]{1}
node [above]{A pour responsable $\RHD$}
node[very near start, below]{*}  
(Prof.160);

\draw [color=\umldrawcolor,text=\umltextcolor] (Module.340) to
node[very near start, above]{1}
node [below]{$\LHD$ Est spécialiste}
node[very near end, above]{*}
(Prof.200);

\draw [color=\umldrawcolor,text=\umltextcolor] (Module.south) |- node[](a){} (Etudiant.west)
node[very near start, left]{*}
node[very near end, above]{*};

\draw [fill,color=\umldrawcolor,dashed] (a) circle (2pt)--(Notation);

\ternaryassociation%
{Module.south}%
{Prof.south}%
{Etudiant}%
{Enseignement}
\end{tikzpicture}
\caption{Traduction UML du modèle conceptuel des données de la base «~Gestion Pédagogique~»\label{uml_gestion_peda}}
\end{figure}

\section{Gestion de la persistance des données avec JPA}
Avant de commencer à travailler, il faut que vous ayez créé grâce à Maven un projet compatible avec JPA2.0 semblable à 
celui du tutoriel. Vous trouverez à cette adresse \url{http://bit.ly/TP_jpa} un squelette de projet 
pour ce TP. Pour l'utiliser, il vous suffit d'extraire l'archive. 
Puis à partir d'Eclipse, allez dans le menu \texttt{File->Import...}, choisir \texttt{Maven->Existing Maven Projects}.
Dans le dialogue sélectionnez le dossier TpJPA, cliquez sur le POM du projet et validez. 

\subsection{Configuration de l'unité de persistance}
Comme toujours avec un projet JPA, vous devez commencer par configurer les paramètres d'accès à la base de données.
Nous allons comme dans le TP précédent utiliser préférentiellement le serveur MySQL installé localement sur les machines 
du département. Pour le configurer correctement avant chaque séance lancez la séquence de commandes suivante :
\begin{code_shell}
mysql --user=root --password=mysql --execute="create database gestionPedaBD"
mysql --user=root --password=mysql --execute="grant all privileges on gestionPedaBD.* to monUser@localhost identified by 'monPassword'"
mysql --user=monUser --password=monPassword gestionPedaBD --execute="source gestion_peda_mysql.sql"
\end{code_shell}

Le fichier \texttt{src/main/resources/META-INF/persistence.xml} devra ressembler à ceci :
\begin{code_xml}
<?xml version="1.0" encoding="UTF-8" ?>

<persistence xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
  xsi:schemaLocation="http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd" 
  version="2.0" xmlns="http://java.sun.com/xml/ns/persistence">
  <persistence-unit name="gestionPedaPU" transaction-type="RESOURCE_LOCAL">
    <provider>org.eclipse.persistence.jpa.PersistenceProvider</provider>
	<class>fr.univaix.iut.progbd.beans.Etudiant</class>
	<class>fr.univaix.iut.progbd.beans.Module</class>
	<class>fr.univaix.iut.progbd.beans.Prof</class>
    <properties>
      <property name="javax.persistence.jdbc.url" value="jdbc:mysql://localhost:3306/gestionPedaBD"/>
      <property name="javax.persistence.jdbc.driver" value="com.mysql.jdbc.Driver"/>
      <property name="javax.persistence.jdbc.user"  value="monUser"/>
      <property name="javax.persistence.jdbc.password"  value="monPassword"/>
      <property name="eclipselink.logging.level" value="ALL"/>
<!--  <property name="eclipselink.ddl-generation"  value="create-tables"/> -->
    </properties>
  </persistence-unit>
</persistence>
\end{code_xml}
Remarquez que contrairement au tutoriel, nous ne demandons pas à JPA de nous créer les tables puisqu'elles existent déjà.
L'une des principales difficultés de ce TP sera de configurer le mapping des entités pour qu'il corresponde aux relations 
présentes dans la BD. Comme vous allez le voir, la BD ne satisfaisant pas à la convention par défaut de JPA,
il faudra rajouter beaucoup d'annotations.

\subsection{Annotations des entités}
La configuration du mapping dans JPA peut se faire grâce au mécanisme des annotations Java. Une annotation est une 
information permettant d'enrichir la sémantique d'une classe sans modifier son code. Dans le tutoriel nous avons déjà 
rencontré plusieurs d'entre elles :
\begin{itemize}
	\item \texttt{@javax.persistence.Entity} permet à JPA de reconnaître cette classe comme une 
	classe persistante (une entité) et non comme une simple classe Java.
	\item \texttt{@javax.persistence.Id}, quant à elle, définit l'identifiant unique de l'objet. Elle donne à 
	l'entité une identité en mémoire en tant qu'objet, et en base de données via une clé primaire. Les autres attributs 
	seront rendus persistants par JPA en appliquant la convention suivante : le nom de la colonne est identique à celui de 
	l'attribut et le type String est converti en \texttt{VARCHAR(255)}.
	\item \texttt{@javax.persistence.GeneratedValue} indique à JPA qu'il doit gérer automatiquement la 
	génération automatique de la clef primaire. 
	\item \texttt{@javax.persistence.Column} permet de préciser des informations sur une colonne de la table : 
	changer son nom (qui par défaut porte le même nom que l’attribut), préciser son type, sa taille et si la colonne 
	autorise ou non la valeur null.
	
	\item \texttt{@javax.persistence.Embedded} précise que la donnée membre devra être intégrée dans l'entité.
	\item \texttt{@javax.persistence.Embeddable} précise que la donnée membre peut être intégrée dans une entité.
	 
	\item L'annotation \texttt{@javax.persistence.OneToOne} indique à JPA que la donnée membre est une association 1:1.
	\item L'annotation \texttt{@javax.persistence.ManyToOne} indique à JPA que la donnée membre est une association N:1.
	\item L'annotation \texttt{@javax.persistence.OneToMany} indique à JPA que la donnée membre est une association 1:N.
	\item L'annotation \texttt{@javax.persistence.ManyToMany} indique à JPA que la donnée membre est une association N:M.
\end{itemize}

\Question Annoter les classes \texttt{Etudiant}, \texttt{Prof} et \texttt{Module} pour qu'elles soient correctement mises 
en correspondance avec leur relation respective. Dans cette question les associations seront ignorées pour le moment. 
Pour pouvoir tester votre code, il faut rajouter l'annotation \texttt{@Transient} devant la déclaration de la donnée 
membre matérialisant l'association.
\Question  Copier la classe \texttt{App} dans la nouvelle classe \texttt{afficheEntite}. Modifier le code de cette classe 
pour qu'elle récupère l'étudiant dont le \texttt{NUM\_ET} est 1106 et l'affiche sur la sortie standard. 
\Question  Copier la classe \texttt{App} dans la nouvelle classe \texttt{ajouteEntite}. Modifier le code de cette classe 
pour qu'elle crée un nouveau module, l'affiche, attend 1 minute et le supprime de la base de données. Vérifier en parallèle 
dans la console SQL que l'ajout et la suppression ont bien lieu.

\subsection{Mapping des associations}
Dans le cours et dans le TP précédent, nous avons vu comment les associations étaient implémentées en Java. En UML les 
associations ont une propriété supplémentaire, la navigabilité. En effet, contrairement au relationnel, une association
peut n'être accessible qu'à l'une de ses extrémités. De manière générale, une association bidirectionnelle peut être 
vue comme une paire d'associations unidirectionnelles de sens opposé. Chacune d'elle pouvvent, comme dans le contexte BD, être 
classées par rapport aux cardinalités en UML de chaque rôle :
\begin{itemize}
  \item Many-to-one pour les associations hiérarchiques (au sens du MCD) qui à une entité départ associe au plus une 
    seule entité cible et une entité cible peut être associée à plusieurs sources.   
  \item One-to-many pour les associations hiérarchiques (au sens du MCD) qui à une entité départ associe plusieurs 
    entités cibles et une entité cible peut être associée à une source.
  \item One-to-one pour les associations hiérarchiques (au sens du MCD) qui à une entité départ n'associe qu'une seule 
    entité cible et une entité cible est associé à au plus une source.
  \item Many-to-many pour les associations qui à une entité départ associe plusieurs entités cibles et une entité cible 
    peut être associée à plusieurs sources.
\end{itemize}

Du point de vue de la source, les deux premières peuvent être implémentées par une simple donnée membre pointant vers 
l'entité associée. Elles sont donc appelées associations monovaluées (ou Single-valued associations). Les deux 
dernières doivent utiliser une collection pour matérialiser tous les liens, on les nomme associations multivaluées 
(ou Collection-valued associations).
\subsubsection{Single-valued associations}
Dans le diagramme de classe UML de la figure~\ref{uml_gestion_peda}, il y a trois associations monovaluées : \textit{"Est père de"}, 
\textit{"Est spécialiste"} du point de vue de la classe \texttt{Prof} et \textit{A pour responsable} du point de 
vue de la classe \texttt{Module}.

Ce type d'association s'implémente avec l'annotation \texttt{@ManyToOne} comme la relation \textit{"à pour département"} 
du tutoriel. En relationnel, elles s'implémentent par l'ajout d'une clef étrangère du coté de la source de l'association.
La convention en JPA pour nommer cet attribut est \texttt{<nom de la clef primaire>\_<nom de la table d'origine>}. Par 
exemple la relation \texttt{DEPARTEMENT} a une clef appelée \texttt{ID} donc la clef étrangère dans \texttt{EMPLOYE} 
s'appelle \texttt{ID\_DEPARTEMENT}. Dans le cas où la clef n'a pas le nom conventionnel, il faut préciser le nom de 
l'attribut clef étrangère (aussi appelé attribut de jointure) avec l'annotation \texttt{@JoinColumn}. Celle-ci possède un 
attribut \texttt{name} comme \texttt{@Column}. Elle doit être placée juste devant la donnée membre matérialisant l'association. 

\Question Annoter les entités pour que les associations \textit{"Est père de"}, \textit{A pour responsable} et 
\textit{"Est spécialiste"} (pour l'instant on considère cette dernière comme unidirectionnelle).
\Question  Copier la classe \texttt{App} dans la nouvelle classe \texttt{afficheResponsable}. Modifier le code de cette classe 
pour qu'elle récupère la matière BD et affiche l'enseignant qui en est responsable sur la sortie standard. Soyez vigilent
que vos méthodes \texttt{toString()} n'essaient pas d'afficher tout le graphe des objets.

\Question  Copier la classe \texttt{App} dans la nouvelle classe \texttt{afficheHierarchieModules}. Modifier le code de 
cette classe pour qu'elle récupère la matière BD et affiche récursivement la hiérarchie des modules de cette matière. 
Observer la console pour bien comprendre comment EclipseLink charge chacun des modules de cette hiérarchie.

Pour éviter que toutes les associations soient chargées dès la première utilisation, les annotations \texttt{OneToOne}, 
\texttt{ManyToOne}, \texttt{OneToMany} et \texttt{ManyToMany} ont un attribut \texttt{fetch} qui permet de demander 
d'effectuer un chargement à la demande (si \texttt{fetch=FetchType.LAZY}) ou un chargement immédiat 
(si \texttt{fetch=FetchType.EAGER}). Cette possibilité évite par exemple que l'ensemble des modules et leur responsable 
soit chargé lorsque l'on charge une seule matière.

Dans le cas des associations 1:1 bidirectionnelle, pour paramétrer le second coté (celui qui ne possédera pas nécessairement 
de clef étrangère dans la BD), il faut rajouter à l'annotation \texttt{@OneToOne} l'attribut \texttt{mappedBy}. Il indique 
le nom de la donnée membre utilisée par l'entité liée pour matérialiser l'association dans le sens opposé.

\subsubsection{Collection-valued associations}
Comme indiqué ci-dessus, les associations 1:N et M:N doivent associer à une entité plusieurs autres. Dans ce cas, la 
donnée membre matérialisant l'association devra être une collection. Par exemple dans le tutoriel si nous souhaitons 
rendre l'association \textit{"à pour département"} navigable dans le sens \texttt{Departement} vers \texttt{Employe}, 
nous devons rajouter dans la classe \texttt{Departement} une donnée membre et les accesseurs suivants :

\begin{code_java}
private Collection<Employe> employes;
public Collection<Employe> getEmployes() {
	return employes;
}
public boolean add(Employe e) {
	return employes.add(e);
}
public boolean remove(Object o) {
		return employes.remove(o);
}
\end{code_java}

Pour paramétrer cette association, il faut lui rajouter l'annotation \texttt{@OneToMany} à laquelle on doit 
préciser le type de l'entité lié et le nom de la donnée membre matérialisant l'association dans l'autre sens. Pour notre
exemple, la déclaration de \texttt{employes} deviendrait :

\begin{code_java}
@OneToMany(targetEntity=Employe.class, mappedBy="departement", fetch=FetchType.EAGER)
private Collection<Employe> employes;
\end{code_java} 

Notons qu'il y a deux points importants à se souvenir quand on définit une association \texttt{one-to-many} 
bidirectionnelle : 
\begin{itemize}
  \item Le coté many-to-one est le propriétaire de l'association, l'attribut de jointure (\texttt{@JoinColumn}) 
  est donc situé de ce coté.
  \item Le coté one-to-many est le coté inverse donc l'attribut \texttt{mappedBy} doit être utilisé. 
\end{itemize}
Si l'on oublie de spécifier l'attribut \texttt{mappedBy} dans l'annotation \texttt{@OneToMany}, JPA considérera 
l'association \texttt{one-to-many} comme unidirectionnelle et s'attendra à trouver une table de jointure dont le nom est 
constitué de la concaténation des noms des entités liées.

\Question Modifier et annoter l'entité \texttt{Module} pour que l'association \textit{"Est spécialiste"} soit bidirectionnelle.
\Question  Copier la classe \texttt{App} dans la nouvelle classe \texttt{afficheSpécialistes}. Modifier le code de cette classe 
pour qu'elle récupère la matière BD et affiche tous les spécialistes de cette matière.

Le dernier type d'association qu'il nous reste à étudier sont les associations many-to-many. Pour ces associations en 
relationnel on utilise des relations dites de jointure. De manière générale, elles sont naturellement bidirectionnelle 
à cause de cette implémentation relationnelle (même si l'on peut restreindre la navigabilité). Comme pour les associations 
\texttt{one-to-many} bidirectionnelles, l'un des cotés doit porter l'attribut \texttt{mappedBy} dans l'annotation 
\texttt{@ManyToMany}. Le coté qui porte cet élément est dit coté inverse alors que le coté qui en est dépourvu sera le 
propriétaire. Chaque coté de l'association doit être doté d'une collection la matérialisant.

Le paramétrage de la table de jointure utilisée se fait grâce à l'annotation @JoinTable du coté de l'entité propriétaire. 
Cette annotation possède trois attributs importants :
\begin{itemize}
  \item \texttt{name} qui indique le nom de la table de jointure.
  \item \texttt{joinColumns} qui spécifie l'attribut de la table de jointure qui est une clef étrangère vers 
  l'entité propriétaire. Cet élément prend pour valeur une annotation \texttt{@JoinColumn} pour donner tous les 
  paramètres de l'attribut de jointure.
  \item \texttt{inverseJoinColumns} qui spécifie le nom de l'attribut de la table de jointure qui est une clef étrangère vers 
  l'entité située coté inverse. De même que \texttt{joinColumns}, cet élément se paramètre avec une annotation \texttt{@JoinColumn}.
\end{itemize}

\Question Modifier et annoter les entités \texttt{Module} et \texttt{Etudiant} pour implémenter l'association 
bidirectionnelle \textit{"Notation"} sans les attributs portés.
\Question Copier la classe \texttt{App} dans la nouvelle classe \texttt{afficheNotation}. Modifier le code de cette classe 
pour qu'elle récupère la matière BD et affiche tous les étudiants ayant été notés pour cette matière.

La gestion des attributs portés et les associations ternaires avec JPA reposent principalement sur le principe de 
promotion d'une association en entité. Le travail demandé étant relativement important nous n'avons pas le temps de le 
faire dans les 4h allouées à ce TP. Pour ceux qui sont intéressés, le mapping complet et la correction seront disponibles 
sur mon dépôt git à la fin de cette semaine.  

\subsection{Construction de la couche d'accès aux données}
Dans ce paragraphe, nous allons, comme dans le TP précédent, construire une couche dédiée à l'accès aux données 
qui utilisera le pattern DAO\footnote{\url{http://java.sun.com/blueprints/corej2eepatterns/Patterns/DataAccessObject.html}} (Data Access Object).
Cette couche encapsulera tous les accès à la source de données. Les autres parties de l'application 
utiliseront uniquement les objets de cette couche pour gérer la persistance. 

Chacune d'elles devra contenir des méthodes pour effectuer les 4 opérations de base pour la persistance des données : 
\textit{créer, récupérer, mettre à jour et supprimer}\footnote{Généralement désigné par l'acronyme anglais CRUD pour 
\textit{Create, Retrieve, Update et Delete}}. Par convention, chacune des classes de DAO devra être 
nommée par "\texttt{DAO}" suivi due nom de la classe métier associée. 

\begin{itemize}
	\item \texttt{insert} qui a pour objectif de créer un nouvel étudiant dans la base de données.
	L'identifiant d'un tuple ne pouvant être connu avant son insertion, cette méthode retourne 
	une copie de l'objet métier passé en paramètre avec un identifiant définitif. L'identité d'un 
	objet dépendant uniquement de l'identifiant, un objet métier créé localement avec le 
	constructeur par défaut (objet temporaire sans identité propre du point de vue de 
	\texttt{equals()} et \texttt{hashCode()}) ne devra participer à aucune association 
	avant d'être inséré dans la base avec cette méthode\footnote{Ces objets sans identité jouent le rôle des objets 
	de transfert de données (\textit{Data Transfer Object}) du pattern DAO original.}.

	\item \texttt{update} qui prend un objet métier en paramètre et essaie faire la mise à jour 
	dans la base de données. La valeur retournée par cette méthode indique si la mise à jour 
	a pu avoir lieu.
	
  \item \texttt{delete} qui prend un étudiant en paramètre et essaie de le supprimer de la base 
  de données. La valeur retournée par cette méthode indique si la suppression a pu avoir lieu.
  
  \item les \texttt{get} qui constituent, avec les \texttt{find}, les méthodes 
  de récupération des données. Les paramètres passés à ces méthodes permettent de récupérer
  uniquement les tuples satisfaisants certains critères. La différence entre ces deux 
  familles de méthodes est que les \texttt{get} doivent retourner exactement un seul 
  résultat alors que les \texttt{find} peuvent en retourner plusieurs.
  
  \item les \texttt{compute} qui, comme leur nom l'indique, ont pour objectif d'effectuer des 
  calculs sur les étudiants. La plupart du temps (sauf si le calcul demande de ne rapatrier 
  aucune donnée) on préférera, pour des raisons d'efficacité, le faire directement dans le \texttt{Sgbd}. 
  Ces méthodes sont donc soit des requêtes \textsc{Sql} agrégatives soit des appels de procédures stockées.	
\end{itemize}

Tous les DAO de notre application ont un certain nombre de méthodes communes. Pour améliorer l'indépendance du code client
vis à vis de la couche de persistance, nous ajoutons une interface \texttt{DAO} que tous les objets DAO devront implémenter. 
Les objets métiers dépendront ainsi d'une interface et non d'une implémentation particulière. La figure~\ref{dao_gestion_peda}
donne le diagramme de classe de l'ensemble des DAO de l'application gestion pédagogique. Dans sa version complète (voir 
code présent sur le dépôt git), le pattern présenté utilise des \texttt{Abstract Factory} pour améliorer encore la 
modularité et l'indépendance de la couche de persistance.  

\begin{figure}\centering\footnotesize
\begin{tikzpicture}
\begin{interface}[text width=4cm]{DAO<T>}{6,0}
\operation{+insert(T):T}
\operation{+delete(T):boolean}
\operation{+update(T):boolean}
\operation{+getById(numT:int):T}
\operation{+findAll():List<T>}
\end{interface}

\begin{interface}[text width=2.5cm]{DAOEtudiant}{2,-5}
\end{interface}

\begin{class}[text width=3cm]{DAOEtudiantJPA}{2,-8}
\end{class}


\begin{interface}[text width=2.3cm]{DAOModule}{6,-5}
\end{interface}

\begin{class}[text width=2.8cm]{DAOModuleJPA}{6,-8}
\end{class}


\begin{interface}[text width=2.3cm]{DAOProf}{10,-5}
\end{interface}

\begin{class}[text width=2.8cm]{DAOProfJPA}{10,-8}
\end{class}

\draw [umlcd style inherit line] (DAO<T>) -- (DAOEtudiant);
\draw [umlcd style inherit line] (DAO<T>) -- (DAOModule);
\draw [umlcd style inherit line] (DAO<T>) -- (DAOProf);

\draw [umlcd style implement line] (DAOEtudiant) -- (DAOEtudiantJPA);
\draw [umlcd style implement line] (DAOModule) -- (DAOModuleJPA);
\draw [umlcd style implement line] (DAOProf) -- (DAOProfJPA);

\end{tikzpicture}
\caption{Diagramme de classe de la couche DAO de l'application gestion pédagogique\label{dao_gestion_peda}}
\end{figure}

\Question
Implémenter la classe \texttt{DAOEtudiantJPA} devant rendre les mêmes services que celle développé dans le TP précédent.  
\Question
Implémenter toutes les classes \texttt{DAO}. 
\Question
Copier la classe \texttt{App} dans la nouvelle classe \texttt{afficheNotation}. 
Modifier le code de celle-ci pour que sa boucle principale récupère tous les étudiants de deuxième année, les affiche, puis 
affiche tous ceux qui ont été notés en « ACSI ».
\Question
L'écriture des opérations CRUD des DAO étant toujours identique, écrire la classe abstraite 
\texttt{DAOGeneriqueJPA<T, ID extends Serializable>} qui implémente \texttt{DAO<T>}. Modifier les DAO précédemment écrits 
pour qu'ils dérivent de cette classe. Vérifier que vos programmes fonctionnent toujours
\end{document}

